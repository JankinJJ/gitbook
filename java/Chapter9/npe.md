# 第1节：npe

## 理论准备
- 使用前一定要记得初始化 或者检查是否初始化
- 尽量避免在函数中返回null 或给出详细的注释
- 外部传值 除非有明确的说明（非null）否则一定要加判断

## 自己总结（理论准备）
- 三目表达式可以用起来 尤其是在获取的是一个对象的时候 需要判断一下是不是null


## 赋值时自动拆箱出现的空指针

#### 为什么需要包装器类型：
java是面对对象的 将基本类型包装起来 使其成为一个对象 还拥有一些方法 

包装器类型有自动拆箱 也会引发空指针异常

#### 哪些场景会发生
变量赋值
方法传参
用于大小比较

#### 为什么自动拆箱出现空指针 ？
因为包装器给基本类型加上了一些方法和属性 那在调用这些方法和属性的时候就可能出现空指针这个异常了
可以使用反编译字节码文件看到 拆箱的时候会调用**longvalue()** 那就会在此处报空指针异常

#### 如何查看字节码
javac xxx.java
javap -c XXX.class

#### 如何规避
1、基本数据类型优于包装器类型
2、对于不确定的包装器类型 一定要检验是否是null
3、值为null的包装器类型 赋值为0


## 字符串、数组、集合出现空指针
1、字符串使用 equals可能会出现空指针错误
2、对象数组new出来后 但是元素没有 初始化
我们只是有数据内存空间 但是每一个内存空间中的对象并没有初始化 所以导致空指针异常
3、List对象add 一个null并不会报错 但是addAll中不可以添加null （看源码即可） 否则会报空指针异常
针对3 进行测试：如果先new一个集合对象 将null加进去 再将该集合对象addAll进去会有空指针异常吗？
推测：不会有空指针异常
结果：没有发生

## 使用Optional规避空指针的时候需要注意什么

Optional是一个容器类 是为了避免空指针异常
可将Optional对象看成一个集合 至多包含一个元素 可以也没有元素
没实现序列化接口
在领域模型中使用Optional小心bug

#### 正确合理使用Optional的API
**Get/ifPresent**这样的方法更应该看成是私有（不要直接去使用）的方法
私有方法是不允许直接访问的 不要直接使用这两个方法

## Try-Catch却没有好好处理异常
1、使用异常 而不是返回码（或类似） 因为异常会更加的详细
2、主动捕获检查性异常 并对异常信息进行反馈（日志或者标记）
3、保持代码整洁 一个方法中不要有多个try-catch 或者嵌套的try-catch
4、捕获更加具体的异常 而不是通用的Exception
5、合理设计自定义的异常类
- 为了标识业务而存在的异常类
- 更加详细的异常信息 
上述两点是合理自定义异常类的前提

#### 常见异常类型
###### 并发修改异常
对资源进行遍历的时候进行修改就会报并发修改异常
举例：在for循环中使用remove方法 
现象：出现并发修改异常
原因：快速失败机制 迭代器工作在独立的线程中 并且拥有一个互斥锁 
迭代器被创建后 会生成一个单链表的索引表 当原来的对象数量发生变化的时候 索引表不会发生改变
所以会直接报并发修改异常
正确做法：使用迭代器玩成这样的操作即可
更好的做法：使用流 的 filter 去过滤而不是删除

###### 类型转换异常
使用instance of 来判断是否是某种类型
使用场景其实多是接口 的实现类

###### 枚举查找异常
解决办法：
1、最普通最简单的实现：try-catch捕获该异常
2、改进实现：for循环（使用枚举类的values()方法去获取枚举类型的数组 依次判断查找）
3、静态的map索引：首先对枚举进行遍历（放在静态代码块中） 然后插入到map  后续通过遍历map来进行判断
4、goole guava 包：有一个工具类 Enums 

#### try-finally的资源泄漏隐患
使用try-with-resources
为什么会选择这个来处理异常资源
1、代码更简洁 
2、如果在try中出现异常 同时也在finally处出现异常 
finally处的异常会抑制try中的异常 这样很难发现代码中存在的异常和错误










