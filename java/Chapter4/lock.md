# 第1节：lock

## 概念
#### 行级锁
Innodb 存储引擎 支持行级锁和表级锁
行级锁是锁住的一条行记录 粒度最细 大大减少并发条件下对于数据库表操作的冲突
不好的点就是：开销大所以加锁很慢 可能出现死锁
#### 表级锁
表级锁就是锁住一整张表 其他绝大多数引擎支持该锁
开销小所以加锁快 不会出现死锁
但是不好的点就是：由于颗粒大，所以加锁的冲突操作会增多 那并发就很低

#### Mysql是如何选择行与表锁的
InnoDB 行级锁是通过给索引上的索引项加锁来实现的 所以 只有通过索引条件检索的数据，才会使用行级锁 否则都是用表级锁
- 不通过索引条件查询的时候，InnoDB一定会使用表锁而不是行锁
- 查询时不论是使用主键索引，唯一索引或者普通的索引 InnoDB都会使用行锁来对数据进行加锁
但是第二点是不确定的 有时候数据量很小 mysql则会认为全表扫描会更快 那就不会使用行锁 即使是走的索引项

#### 悲观锁与乐观锁
##### 悲观锁
- 字面上理解：一切都是往最不好的方向上考虑 也就是遇到数据并发的时候，会自动认定为会发生并发问题 则就会去加锁
- 实质上：
    - 对数据操作之前 尝试获取锁
    - 获取锁成功 对数据进行修改、提交事务、最后释放锁
    - 获取锁失败 则锁正在被占用，等待或抛出异常

##### 乐观锁
- 字面上理解： 一切都是往好的方向想 也就是在数据并发的操作下  会自动认为不会发生并发问题 
- 实质上：
    - 乐观锁与悲观锁是相对的 他假定数据一般不会发生冲突 所以在数据进行提交更新的时候 才会正式对数据的冲突与否进行检测
    - 她不是真正意义上的锁 所以也不需要数据库的锁机制 因此在操作的时候不需要加锁，在提交的时候再做判断 
    - 也不会发生死锁的情况
